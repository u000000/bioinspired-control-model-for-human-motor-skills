# -*- coding: utf-8 -*-
"""controller .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_FMXEjnhv2fcZBfP2uL5VZjnV83u2P8K
"""

!pip install sympy
!pip install roboticstoolbox-python
!pip install scipy
!pip install install visual-kinematics

import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
# Define joint angles and angular velocities as symbols
q_symbols = sp.symbols('q1:7')  # theta1 to theta6
qd_symbols = sp.symbols('qd1:7')  # omega1 to omega6
qdd = sp.symbols('qdd1:7')  # Joint accelerations
g_const = 9.81  # gravitational acceleration

# Given specific values for q and qd
q_values = [1, 1, 1, 1, 1, 1]
qd_values = [1, 1, 1, 1, 1, 1]

# Define DH parameters
a = [0, -0.425, -0.3922, 0, 0, 0]  # link lengths
d = [0.1625, 0, 0, 0.1333, 0.0997, 0.0996]  # link offsets
alpha = [sp.pi/2, 0, 0, sp.pi/2, -sp.pi/2, 0]  # link twists

# Masses and inertia tensors (placeholders, specify actual values)
mass = [3.761, 8.058, 2.846, 1.37, 1.3, 0.365]
inertia_tensors = [
    sp.diag(0.001, 0.001, 0.001),
    sp.diag(0.002, 0.002, 0.002),
    sp.diag(0.0015, 0.0015, 0.0015),
    sp.diag(0.001, 0.001, 0.001),
    sp.diag(0.001, 0.001, 0.001),
    sp.diag(0.0001, 0.0001, 0.0002)
]

# Compute transformation matrices from base to each joint
T_base_to_i = [sp.eye(4)]
for i in range(6):
    T_i = sp.Matrix([
        [sp.cos(q_symbols[i]), -sp.sin(q_symbols[i])*sp.cos(alpha[i]),  sp.sin(q_symbols[i])*sp.sin(alpha[i]), a[i]*sp.cos(q_symbols[i])],
        [sp.sin(q_symbols[i]),  sp.cos(q_symbols[i])*sp.cos(alpha[i]), -sp.cos(q_symbols[i])*sp.sin(alpha[i]), a[i]*sp.sin(q_symbols[i])],
        [0, sp.sin(alpha[i]), sp.cos(alpha[i]), d[i]],
        [0, 0, 0, 1]
    ])
    T_base_to_i.append(T_base_to_i[i] * T_i)

# Define functions to compute B, C, and g
def compute_inertia_matrix(T_base_to_i, mass, inertia_tensors):
    B = sp.zeros(6, 6)
    for i in range(6):
        R = T_base_to_i[i+1][:3, :3]
        p = T_base_to_i[i+1][:3, 3]
        Jv = sp.Matrix([[sp.diff(p[j], qk) for qk in q_symbols] for j in range(3)])
        Jw = R  # Assume Jw is just the rotation matrix

        Jv_full = sp.zeros(6, 6)
        Jv_full[:3, :] = Jv
        Jw_full = sp.zeros(6, 6)
        Jw_full[3:, 3:] = Jw

        inertia_extended = sp.zeros(6, 6)
        inertia_extended[3:, 3:] = inertia_tensors[i]

        B += Jv_full.T * mass[i] * Jv_full + Jw_full.T * inertia_extended * Jw_full
    return B

def compute_coriolis_matrix(B, q_symbols, qd_symbols):
    C = sp.zeros(6, 6)
    for i in range(6):
        for j in range(6):
            C[i, j] = sum(0.5 * (sp.diff(B[i, j], q_symbols[k]) + sp.diff(B[i, k], q_symbols[j]) - sp.diff(B[j, k], q_symbols[i])) * qd_symbols[k] for k in range(6))
    return C

def gravity_vector(T_base_to_i, mass):
    g_vector = sp.zeros(6, 1)
    for i in range(6):
        z = T_base_to_i[i+1][:3, 2]  # Z axis of each transformation matrix
        g_vector[i] = -mass[i] * g_const * z.dot(sp.Matrix([0, 0, 1]))  # Dot product with gravity direction
    return g_vector
# Compute matrices symbolically
B_sym = compute_inertia_matrix(T_base_to_i, mass, inertia_tensors)
C_sym = compute_coriolis_matrix(B_sym, q_symbols, qd_symbols)
g_sym = gravity_vector(T_base_to_i, mass)
B_num = B_sym.subs(list(zip(q_symbols, q_values)))
C_num = C_sym.subs(list(zip(q_symbols + qd_symbols, q_values + qd_values)))
g_num = g_sym.subs(list(zip(q_symbols, q_values)))

def forward_kinematics(theta):
    # Constants for the UR5e robot
    a = [0, -0.425, -0.3922, 0, 0, 0]
    d = [0.1625, 0, 0, 0.1333, 0.0997, 0.0996]
    alpha = [np.pi/2, 0, 0, np.pi/2, -np.pi/2, 0]

    # Transformation matrices for each joint
    T = np.identity(4)
    for i in range(len(theta)):
        Ti = np.array([[np.cos(theta[i]), -np.sin(theta[i])*np.cos(alpha[i]), np.sin(theta[i])*np.sin(alpha[i]), a[i]*np.cos(theta[i])],
                       [np.sin(theta[i]), np.cos(theta[i])*np.cos(alpha[i]), -np.cos(theta[i])*np.sin(alpha[i]), a[i]*np.sin(theta[i])],
                       [0, np.sin(alpha[i]), np.cos(alpha[i]), d[i]],
                       [0, 0, 0, 1]])
        T = np.dot(T, Ti)

    return T

# Calculate the Jacobian for the UR5e robot
def calculate_jacobian(theta):
    # Initialize Jacobian as a 6x6 matrix of zeros
    J = np.zeros((6, 6))

    # Initial frame reference
    T0 = np.identity(4)
    Z0 = T0[:3, 2]
    # Position of the end-effector
    T = forward_kinematics(theta)
    p_e = T[:3, 3]

    # Calculate the Jacobian columns
    for i in range(len(theta)):
        T = forward_kinematics(theta[:i+1])
        Z = T[:3, 2]
        p = T[:3, 3]

        J[:3, i] = np.cross(Z0, (p_e - p))
        J[3:, i] = Z0

    return J

# Numerical approximation of the Jacobian derivative (for demonstration purposes)
def numerical_jacobian_derivative(theta, theta_dot, delta_t=0.01):
    theta = np.array(theta)  # Convert theta to a numpy array if it isn't already
    theta_dot = np.array(theta_dot)
    J = calculate_jacobian(theta)
    J_next = calculate_jacobian(theta + theta_dot * delta_t)
    J_dot = (J_next - J) / delta_t
    return J_dot


def simulate_robot(q_init, qd_init, dt, num_steps, B_sym, C_sym, g_sym, T_base_to_i,tau):
    # Convert symbolic expressions to numerical functions using numpy
    B_func = sp.lambdify([(q_symbols, qd_symbols)], B_sym, "numpy")
    C_func = sp.lambdify([(q_symbols, qd_symbols)], C_sym, "numpy")
    g_func = sp.lambdify([q_symbols], g_sym, "numpy")
    T_func = sp.lambdify([q_symbols], T_base_to_i[-1], "numpy")

    # Initialize state vectors
    q_values = np.array(q_init, dtype=float)
    qd_values = np.array(qd_init, dtype=float)
    qdd_values = np.zeros_like(q_values)
    # Initialize trajectory storage
    end_effector_positions = []

    for i in range(num_steps):



        tau_values = tau
        # Calculate joint accelerations from dynamics equation
        B_matrix = B_func((q_values, qd_values))
        C_matrix = C_func((q_values, qd_values))
        g_vector = g_func(q_values)

        # Ensure dimensions are correct for solving
        B_matrix = np.squeeze(np.array(B_matrix, dtype=float))
        C_matrix = np.squeeze(np.array(C_matrix, dtype=float))
        g_vector = np.squeeze(np.array(g_vector, dtype=float))

        # Solve for qdd
        qdd_values = np.linalg.solve(B_matrix, tau_values - np.dot(C_matrix, qd_values) - g_vector)

        # Integrate to find qd and q
        qd_values += qdd_values * dt
        q_values += qd_values * dt

        # Calculate the end-effector position
        T_matrix = T_func(q_values)
        end_effector_position = T_matrix[:3, 3]
        end_effector_positions.append(end_effector_position.ravel())

    return q_values ,qd_values ,np.array(end_effector_positions)

# Define the parameters for the simulation
dt = 0.01  # Timestep duration
num_steps = 2  # Number of steps
#q_init = [0,0,0,0,0,0]  # Initial joint angles
#qd_init =[0,0,0,0,0,0]  # Initial joint velocities
#self.ada_imp =ada_imp_con(6) # degree of freedom of robot arm



class AdaImpCon:
    """Online impedance adaptation for robot arms."""

    def __init__(self, dof):
        """Initialize the class with the degrees of freedom for the robot arm."""
        self.DOF = dof
        self.k_mat = np.zeros((self.DOF, self.DOF))  # Stiffness parameter matrix
        self.b_mat = np.zeros((self.DOF, self.DOF))  # Damping parameter matrix
        self.ff_tau_mat = np.zeros((self.DOF, 1))

        self.q = np.zeros((self.DOF, 1))  # Real joint angle matrix
        self.q_d = np.zeros((self.DOF, 1))  # Desired joint angle matrix

        self.dq = np.zeros((self.DOF, 1))  # Real joint velocity matrix
        self.dq_d = np.zeros((self.DOF, 1))  # Desired joint velocity matrix

        self.a = 0.2  # Adaptation parameter
        self.b = 5.0  # Adaptation parameter
        self.k = 0.05  # Gain parameter

    def update_impedance(self, q, q_d, dq, dq_d):
        """Update stiffness and damping matrices based on current and desired states."""
        self.q = np.array(q).reshape(self.DOF, 1)
        self.q_d = np.array(q_d).reshape(self.DOF, 1)
        self.dq = np.array(dq).reshape(self.DOF, 1)
        self.dq_d = np.array(dq_d).reshape(self.DOF, 1)

        self.k_mat = np.dot(self.gen_track_err(), self.gen_pos_err().T) / self.gen_for_factor()
        self.b_mat = np.dot(self.gen_track_err(), self.gen_vel_err().T) / self.gen_for_factor()

        return self.k_mat, self.b_mat

    def gen_pos_err(self):
        """Calculate position error."""
        return self.q - self.q_d

    def gen_vel_err(self):
        """Calculate velocity error."""
        return self.dq - self.dq_d

    def gen_track_err(self):
        """Calculate tracking error."""
        return self.k * self.gen_vel_err() + self.gen_pos_err()

    def gen_for_factor(self):
        """Generate a normalization factor for updating the impedance."""
        return self.a / (1.0 + self.b * la.norm(self.gen_track_err())**2)


ada_imp = AdaImpCon(6)
t = 0
t_max = 50
q = [1, 1, 1, 1, 1, 1]
dq = [0, 0, 0, 0, 0, 0]
q_d = [1, 1, 1, 1, 1, 1]
dq_d = [0, 0, 0, 0, 0, 0]
while t < t_max:
     k_mat, b_mat = ada_imp.update_impedance(q, q_d, dq, dq_d)
     tau_fb = np.dot(k_mat, (np.array(q_d) - np.array(q))) + np.dot(b_mat, (np.array(dq_d) - np.array(dq)))
     # Compute total joint torques, simulate robot, update q, dq as needed
     print(tau_fb)
     q,dq,end_effector_positions = simulate_robot(q, dq, dt, 1, B_sym, C_sym, g_sym, T_base_to_i,tau_fb)
     print(end_effector_positions)
     t += 1